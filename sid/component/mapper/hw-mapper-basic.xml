<?xml version="1.0" ?>
<!DOCTYPE defcomplib SYSTEM "http://sources.redhat.com/sid/component.dtd">

<defcomplib lib="libmapper.la" dlsym="mapper_component_library">
  <defcomponent name="hw-mapper-basic" type="concrete">


    <!-- buses -->
    <defbus name="access-port" addresses="any address" accesses="any access" behaviors="mapping" />


    <!-- accessors -->
    <defaccessor name="ACCESSOR, any of the specified forms" accesses="any access" behaviors="configuration, mapping" />


    <!-- attributes -->
    <defattribute name="access-count" category="register" legalvalues="number" defaultvalue="0" behaviors="mapping" />
    <defattribute name="cache-hit-count" category="register" legalvalues="number" defaultvalue="0" behaviors="mapping" />
    <defattribute name="ACCESSOR-count" category="register" legalvalues="number" defaultvalue="0" behaviors="mapping" />
    <defattribute name="latency" category="setting" legalvalues="number" defaultvalue="0" behaviors="memory latency" />
    <defattribute name="state-snapshot" legalvalues="opaque string" behaviors="state save/restore" />
  </defcomponent>
  <synop>
    <p>
      This component is a generalized model of the distributed computer
      circuitry that decodes bus addresses.</p>
  </synop>
  <func>
    <modelling>
      <p>
	<p>
	  This component distributes bus accesses to one of a number of
	  configured bus accessors, depending on the address of the
	  incoming memory access.</p>  
	<p>
	  A mapper defines an address space.  The address space is
	  decomposed into non-overlapping regions by configuring a dynamic
	  collection of accessors.  Each accessor is connected to a single
	  slave bus.  To configure the address mapping, you must name each 
	  accessor according to one of these forms:
	  
	  <ul>
	    <li><tt>[&lt;low&gt;-&lt;high&gt;]</tt></li>
	    <li><tt>[&lt;low&gt;-&lt;high&gt;,&lt;wordsize&gt;]</tt></li>
	    <li><tt>[&lt;low&gt;-&lt;high&gt;,&lt;stride&gt;,&lt;width&gt;]</tt></li>
	    <li><tt>[&lt;low&gt;-&lt;high&gt;,&lt;stride&gt;,&lt;width&gt;,&lt;wordsize&gt;]</tt></li>
	  </ul>

	  where:
	  <ul>
	  <li><tt>
	    &lt;low&gt;</tt> is the starting address for the mapped region. </li>
	  <li><tt>
	    &lt;high&gt;</tt> is the ending address for the mapped region. </li>
	  <li><tt>
	    &lt;stride&gt;</tt> is the step size between addressable units. </li>
	  <li><tt>
	    &lt;width&gt;</tt> is the width of addressable units. </li> 
	  <li><tt>
	    &lt;wordsize&gt;</tt> is the number of bytes in an address unit:
	  a constant multiplier you can use to permit specifying &lt;low&gt;, &lt;high&gt;,
	  &lt;stride&gt; and &lt;width&gt; in terms of multi-byte words.</li>
	  </ul>
	</p>
	
	<p>
	  In addition, any text may appear outside the "[" and "]" brackets,
	  as long as that text does not include any of the separator
	  characters "[" "]" "-" ",".</p>
	
	<p>
	  Each number may be specified in decimal, hexadecimal, octal, and
	  binary forms, with the appropriate prefix (none, "0x", "0",
	  "0b", respectively).</p>
	
	<p>
	  The first form is appropriate if the slave device is willing to
	  accept all possible sid::bus accesses (subject to the address
	  range limits).  The second form is appropriate if the slave
	  device is willing to accept only accesses to addressable units
	  of fixed width at a fixed stride from one another.</p>
	
	<p>
	  See the "mapping" behavior below for more details.</p></p>
    </modelling>
    <behavior name="configuration">
      <p>
	<p>
	  When an accessor of the prescribed format is set, and the
	  address range is valid, the supplied bus is registered in the
	  decoding table.  Future accesses on the <bus>access-port</bus> bus will
	  consider that address range as a candidate.</p>
	<p>
	  Reasons for rejecting an address range include overlapping with
	  an existing entry, or inconsistent ranges or stride/width
	  values.</p></p>
    </behavior>
    <behavior name="mapping">
      <p>
	<p>
	  When an incoming access on the <bus>access-port</bus> bus is
	  received, its base address is compared to all the registered
	  outgoing accessors.  If one is found that contains the
	  address, the current address is transformed according to the
	  following rules:

	  <ul>
	    <li>
	      The accessor's &lt;low&gt; address is subtracted from the incoming
	      address, so outgoing addresses will be relative and zero-based.</li>
	    <li>
	      If the accessor has stride/width values, divide the relative
	      address by the quotient (&lt;stride&gt;/&lt;width&gt;).  As a result,
	      outgoing addresses will refer to consecutive addressable units, 
	      and an outgoing access of the desired width will be made.</li>
	    <li>
	      If the accessor has no stride/width values, the relative
	      address and the incoming access width will be used to make
	      an outgoing access.</li></ul></p>
	
	<p>
	  This component will return an incoming access prematurely with
	  <tt>sid::bus::unmapped</tt> if no accessor covers the incoming address.
	  Similarly, it will signal a <tt>sid::bus::misaligned</tt> condition if
	  an incoming access could be handled by a stride/width accessor,
	  but the addressed bytes don't cover exactly one addressable
	  unit.</p>
	
	<p>
	  Whenever an incoming access is attempted, the component
	  increments its <attribute>access-count</attribute> attribute.  When a repeated access
	  hits an internal mapping cache, the <attribute>cache-hit-count</attribute> is
	  incremented.  Whenever an incoming address is contained in a
	  specific accessor's address interval, the <attribute>ACCESSOR-count</attribute>
	  attribute is incremented.  (The ACCESSOR string is the name of
	  the accessor.)</p></p>
    </behavior>
    <behavior name="memory latency">
      <p>
        <p>
          This component models constant latency for accesses which
          pass through the mapper.  The value of the
          <attribute>latency</attribute> is added to the total latency
          of every bus transaction.  The units of latency are nominal,
          but typically represent a number of system clock
          cycles.</p></p>
    </behavior>
    <convention name="functional" supported="true">
      <p>
	This is a functional component.</p>
    </convention>
    <convention name="latency" support="true">
      <p>
        This component models memory latency.</p>
    </convention>
    <convention name="triggerpoints" supported="false">
      <p>
	This component does not support triggerpoints.</p>
    </convention>
    <convention name="state save/restore" supported="false">
      <p>
	This component does not support state save/restore.</p>
    </convention>
  </func>
  <env>
    <p>
    <title>
	Related components</title>
      <p>
	Commonly, this component will be placed between a CPU and an
	array of bus peripherals.  The hw-glue-probe-bus component may
	be used in conjunction with this component to analyze and
	troubleshoot bus configuration problems, being chained to either
	the CPU side of the mapper or the peripherals side.
      </p>
      <p>
	An illustration of a simple configuration for an ARM7T system
	with a main memory and a memory mapped UART follows:
	
	<code>	new hw-cpu-arm7t cpu
	new hw-mapper-basic bus
	new hw-uart-ns16550
	new hw-memory-ram/rom-basic mem
	set mem size 4194304
	connect-bus cpu insn-memory bus access-port
	connect-bus cpu data-memory bus access-port
	connect-bus bus [0xD800000,0xD80001F,4,1] uart Bus
	connect-bus bus [0x0,0x400000] mem read-write-port</code>
	
	Here, the CPU's accessors are connected directly to the mapper.
	All peripherals are connected downstream from the mapper.  They
	will have their bus transactions routed to them by the mapper,
	by virtue of configuration.</p></p>
  </env>
</defcomplib>

